# Number Series, Wrapper and Benchmark

The task is to estimate a performance overhead of indirect calls through a smart pointer.
For this purpose, implement a [number_series](include/number_series.hpp) class to store integer numbers and [number_series_wrap](include/number_series.hpp) which wraps number_series class through a smart pointer and provides the same interface.

When implementing the functionality, please follow test driven development process where a test is added first, and functionality is added to satisfy the test.

1. Check that the initial project works: select `All CTest` target and run, all tests should pass. **Ask for help if something does not work**, see if you can work with [main.cpp](tests/main.cpp) instead, try running just `main`.

2. Implement [number_series](include/number_series.hpp) class:
   - Uncomment one test at a time in [number_series_test.cpp](tests/number_series_test.cpp), recompile, run `number_series_test` and observe errors and test failures. 
   - Implement missing functionality (solve `TODO:` comments) in [number_series.hpp](include/number_series.hpp) until `number_series_test` passes. Hint: Use `std::vector<int>` to model the data storage.
   - Maintain the **minimum** and the **maximum** values of the stored numbers as members of your class (so that you do not have to (re)compute them on-demand).
   - Implement the necessary *constructors/destructors/assignment operators*. Implement them only if the ones generated by default are not good. Study Section 17.6 or Item 17 in EMC++ to learn about what is generated by the compiler.
   - Your class should have a **static** member factory function `make_random` that returns a random number series of a desired length. See [uniform_int_distribution example](https://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution) how to generate random numbers.
   - Implement `operator+` and `operator+=` to add two number series element-wise. Use DRY (Don't Repeat Yourself) principle. If number series have different lengths, treat missing numbers as zeros.
   - Implement `operator<` to compare the *amplitudes* of two number series. The amplitude is the difference between the *maximum* and the *minimum* values.
3. Create a wrapper class [number_series_wrap](include/number_series.hpp):
   - has just one private data member: `std::unique_ptr<number_series>` and 
   - the same interface as "number_series".
   - Think about the special members (constructors, destructors,assignment operators), that you may need to provide or rely on the default ones. 
   - Use DRY (Don't Repeat Yourself) principle: reuse as much code as possible by calling number_series methods and previously defined operations (do not copy-paste!), use constructor chaining if possible. 
   - All tests in `number_series_test` should pass.
4. Solve `TODO`s in [number_series_bm.cpp](tests/number_series_bm.cpp) benchmark and run `number_series_bm` target in `Release` profile:
   - Fill a vector of `100'000` random number series, each with `100` elements.
   - Add a random number series to each of number series in the vector.
   - Sort the vector according to the amplitudes of number series. 
   - Record how much time it takes to sort (remember to write down the timings in comments).
   - What is faster? sorting plain number_series or number_series_wrap objects?  
     Measure the performance and see whether your expectations were confirmed. 
5. Add `int dummy[100];` as an extra data member of [number_series](include/number_series.hpp).
   - Rerun `number_series_bm` again.
   - Did the performance change? How? Why?

In your code, pay attention to **safety** and **performance**:
1. Use `const` whenever it makes sense (arguments, member functions). 
2. Use pass-by-reference for efficiency whenever possible.
3. Avoid using plain pointers.
4. Use `Release` profile (without `Debug` information overhead) when *benchmarking*. To add `Release` profile in CLion visit `Settings` > `Build, Execution and Deployment` > `CMake` > `Profiles` and click `+`, it should create `Release` profile automatically (no further tweaking should be needed).

## Unit Tests
[number_series_test.cpp](tests/number_series_test.cpp) includes unit tests to guide you through the implementation.

## Benchmarks
[sort_bm.cpp](tests/sort_bm.cpp) includes a sorting example demonstrating how to use Google Benchmark library.
[number_series_bm.cpp](tests/number_series_bm.cpp) your code for benchmarking the `number_series` and `number_series_wrap`.

## Libraries included
- [doctest](https://github.com/doctest/doctest): unit test framework.
- [Google Benchmark](https://github.com/google/benchmark): microbenchmark support library.

CMake should fetch those libraries automatically during `cmake` reload, and the libraries should build automatically when building the project.